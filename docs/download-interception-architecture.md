---
summary: 'Download interception architecture: fetch patch, simulated clicks, download suppression'
read_when:
  - Modifying the download flow or fetch interception logic
  - Debugging image downloads, duplicate downloads, or cross-world communication
  - Understanding isTrusted / simulated clicks / download suppression
---

# Original Image Download Interception: Architecture & Decision Record

## 1. Background

### 1.1 Core Objective

Batch-download **original full-size images** (PNG, typically ~7 MB) generated by Google Gemini, rather than the thumbnails displayed on the page (JPEG, 1024 px).

### 1.2 Gemini Image URL System

Gemini uses two completely different image URL schemes:

| Type | URL Path | Purpose | Example |
|------|----------|---------|---------|
| Display URL | `/gg/AMW1TP...` | In-page thumbnail | `lh3.googleusercontent.com/gg/AMW1TP...=s1024-rj` |
| Download URL | `/gg-dl/AOI_d_...` | Signed URL triggered by the native download button | `lh3.googleusercontent.com/gg-dl/AOI_d_...=s0-d-I` |

**Key finding: display URLs and download URLs use entirely different tokens.** Rewriting the display URL suffix (e.g. `=s0`) cannot retrieve the original image.

### 1.3 Rejected Approach: URL Suffix Rewriting

The initial attempt was to rewrite the display URL suffix from `=s1024-rj` to `=s0`, hoping to fetch the full-size image.

**Why it failed:**
- Display URLs (`/gg/AMW1TP...`) and download URLs (`/gg-dl/AOI_d_...`) carry completely different signed tokens
- `=s0` merely tells the CDN "no size limit", but the token itself determines whether the original file is accessible
- The display token can only return a JPEG preview, regardless of size parameters

## 2. Reverse Engineering the Gemini Native Download Flow

Full reconstruction of the "Download full size" button's download chain via Chrome DevTools packet capture:

### 2.1 Flow Overview

```
User clicks "Download full size"
    │
    ▼
[1] POST /_/BardChatUi/data/batchexecute
    RPC: c8o8Fe
    Body: image token + session ID + CSRF token
    │
    ▼
[2] Response returns a signed gg-dl URL
    https://lh3.googleusercontent.com/gg-dl/AOI_d_...=d-I?alr=yes
    │
    ▼
[3] GET gg-dl URL → 302 redirect
    → work.fife.usercontent.google.com/rd-gg-dl/...=s0-d-I?alr=yes
    (content-type: text/plain, contains the next-hop URL)
    │
    ▼
[4] GET rd-gg-dl URL → 302 redirect
    → lh3.googleusercontent.com/rd-gg-dl/...=s0-d-I?alr=yes
    (content-type: text/plain, contains the final URL)
    │
    ▼
[5] GET final URL → image/png (~7 MB)
    Original full-size PNG image
    │
    ▼
[6] Page JS creates blob: URL → <a download>.click() → triggers browser download
```

### 2.2 RPC Request Format (c8o8Fe)

```
POST /_/BardChatUi/data/batchexecute

Body:
f.req=[[["c8o8Fe", INNER_JSON, null, "generic"]]]
&at=CSRF_TOKEN    // from WIZ_global_data.SNlM0e

INNER_JSON contains:
- Image token (e.g. "$AedXnj...")    // held in Angular component memory
- Content type URL
- Prompt text
- Response/session IDs (r_xxx, rc_xxx, c_xxx)
- Session-level token
```

### 2.3 Why We Cannot Construct the RPC Request Directly

- **Image token is inaccessible**: tokens (e.g. `$AedXnj...`) are stored in Angular component memory; production mode Angular does not expose `ng.getComponent()` or similar debug APIs
- **Complex session parameters**: requires CSRF token, session ID, response ID, and other parameters that change across sessions
- **High maintenance cost**: the RPC format is an internal protocol subject to change at any time

## 3. Current Approach: Intercepting the Native Download Flow

### 3.1 Core Idea

Since we cannot construct the download request ourselves, we **piggyback on Gemini's own download logic** — trigger the native download button, let the page JS handle all RPC and redirect work, and intercept the fetched image blob at the final step.

### 3.2 Architecture Diagram

```
┌─────────────────────────────────────────────────────────┐
│ Main World (page JS context)                            │
│                                                         │
│  download-interceptor.js (injected via <script src>)    │
│  ┌─────────────────────────────────────────────────┐    │
│  │ Patch window.fetch                              │    │
│  │    - Intercept /gg-dl/ and /rd-gg-dl/ responses │    │
│  │    - Clone blob when content-type is image/*    │    │
│  │    - Convert to dataURL, send via postMessage   │    │
│  └─────────────────────────────────────────────────┘    │
│                                  │ postMessage          │
│                                  ▼                      │
├──────────────────────────────────┼──────────────────────┤
│ Isolated World (Content Script)  │                      │
│                                  │                      │
│  src/content/index.ts            │                      │
│  ┌───────────────────────────────┼─────────────────┐    │
│  │ startDownload() flow:         │                 │    │
│  │  1. Tell Background to enable │                 │    │
│  │     suppress (cancel blob dl) │                 │    │
│  │  2. For each selected image:  │                 │    │
│  │     a. Find <img> by          │                 │    │
│  │        thumbnailUrl           │                 │    │
│  │     b. Traverse up to         │                 │    │
│  │        .overlay-container     │                 │    │
│  │     c. Locate native dl btn   │                 │    │
│  │     d. button.click()         │                 │    │
│  │     e. Wait for postMessage   ◄─── GBD_IMAGE   │    │
│  │        returning dataUrl           _CAPTURED    │    │
│  │     f. Send to Background     │                 │    │
│  │  3. Tell Background to        │                 │    │
│  │     disable suppress          │                 │    │
│  └─────────────────────────┬───────────────────────┘    │
│                            │ chrome.runtime             │
│                            │ .sendMessage               │
├────────────────────────────┼────────────────────────────┤
│ Service Worker (Background)▼                            │
│                                                         │
│  src/background/index.ts                                │
│  ┌─────────────────────────────────────────────────┐    │
│  │ processAndDownload(dataUrl, filename):           │    │
│  │  1. dataUrl → blob                              │    │
│  │  2. removeWatermarkFromBlob(blob)               │    │
│  │  3. blob → processedDataUrl                     │    │
│  │  4. chrome.downloads.download() saves file      │    │
│  │                                                 │    │
│  │ Native download suppression                     │    │
│  │ (chrome.downloads.onCreated):                   │    │
│  │  - When suppress is on, auto-cancel non-own     │    │
│  │    blob: downloads to prevent duplicates        │    │
│  └─────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────┘
```

### 3.3 Key Files

| File | Runtime | Responsibility |
|------|---------|----------------|
| `public/download-interceptor.js` | Main World | Patch fetch to capture original image blobs |
| `src/content/index.ts` | Isolated World | UI panel + download flow orchestration |
| `src/background/index.ts` | Service Worker | Watermark removal + file save + native download suppression |

### 3.4 Cross-World Communication

Content Script (Isolated World) and Interceptor (Main World) cannot call each other's functions directly. They communicate through two channels:

| Direction | Mechanism | Purpose |
|-----------|-----------|---------|
| Main → Content | `window.postMessage({ type: 'GBD_IMAGE_CAPTURED' })` | Return captured image data |
| Content → Background | `chrome.runtime.sendMessage({ type: 'SUPPRESS_DOWNLOADS' })` | Control native download suppression |
| Content → Background | `chrome.runtime.sendMessage({ type: 'DOWNLOAD_IMAGE' })` | Send dataUrl for watermark removal + save |

Main → Content uses `postMessage` (the only viable mechanism for cross isolated/main world communication). Content → Background uses the standard `chrome.runtime.sendMessage`.

## 4. Evolution of the Native Download Suppression Mechanism

During development, "how to suppress Gemini's own blob: download" went through three iterations before a reliable solution was found. This journey illustrates the many constraints of cross-world communication in Chrome extensions.

### 4.1 Attempt 1: Patch `HTMLAnchorElement.prototype.click` in Main World + `CustomEvent` Control

**Idea**: In the main world's `download-interceptor.js`, do two things simultaneously:
1. Patch `HTMLAnchorElement.prototype.click` to intercept all `.click()` calls on `blob:` links
2. Content Script sends control signals via `document.dispatchEvent(new CustomEvent('gbd-control', { detail: { suppress: true } }))` to notify the main world when to enable/disable interception

**Why it failed**:

`CustomEvent.detail` **cannot cross the isolated/main world boundary**. Chrome's isolated world and main world share the same DOM but have separate JavaScript contexts. When a content script creates a `CustomEvent` and dispatches it on the DOM, the main world receives an event object whose `.detail` property is always `null`.

This is a Chrome security design to prevent object references from the isolated world leaking into the main world:
- `CustomEvent.detail` stores a JavaScript object reference
- Isolated world and main world have separate JS heaps
- When crossing worlds, Chrome does not automatically serialize/clone the `detail` object — it simply sets it to `null`
- This differs from `window.postMessage`, which uses the Structured Clone Algorithm to automatically serialize message data

**Key lesson**: To pass data from isolated world → main world, only `window.postMessage` works — not `CustomEvent.detail`.

### 4.2 Attempt 2: Patch `HTMLAnchorElement.prototype.click` in Main World + `postMessage` Control

**Idea**: Since `CustomEvent.detail` doesn't work, switch to `window.postMessage` for the control signal. Content script sends `postMessage({ type: 'GBD_SUPPRESS', suppress: true })`, and the main world listens to toggle the anchor click patch on/off.

**Why it failed**:

**`HTMLAnchorElement.prototype.click` itself is unreliable.** The way Gemini's page JS ultimately triggers the download is not necessarily by calling `anchor.click()`. There are multiple ways to trigger a download from an `<a>` element:

```javascript
// Method 1: Direct .click() call (the one we patched)
anchor.click();

// Method 2: dispatchEvent (bypasses prototype patch)
anchor.dispatchEvent(new MouseEvent('click', { bubbles: true }));

// Method 3: Direct location change (bypasses DOM entirely)
window.location.href = blobUrl;

// Method 4: Navigation API
navigation.navigate(blobUrl);
```

Through packet analysis, Gemini's frontend code fetches the image blob, creates an `<a>` element with `href` set to a `blob:` URL and a `download` attribute, then triggers a click. But whether it uses `.click()` or `dispatchEvent(new MouseEvent('click'))` depends on Angular's internal implementation and may differ across versions.

Even if we patch both `.click()` and listen for `click` event bubbling on `document`:
- `dispatchEvent`-triggered events on elements detached from the DOM do not bubble
- Gemini may create a temporary `<a>` element, never insert it into the DOM, click it, then discard it

**Key lesson**: Intercepting browser downloads via JS patches in the main world is fundamentally a race to "predict all possible page behaviors" — it can never be 100% reliable.

### 4.3 Final Solution: `chrome.downloads.onCreated` in the Background

**Idea**: Abandon page-level JS interception entirely; intercept at the browser API level instead.

```typescript
// background/index.ts
let suppressNativeDownloads = false;
const ownDownloadIds = new Set<number>();

chrome.downloads.onCreated.addListener((item) => {
    if (suppressNativeDownloads && !ownDownloadIds.has(item.id) && item.url.startsWith('blob:')) {
        chrome.downloads.cancel(item.id);
        chrome.downloads.erase({ id: item.id });
    }
});
```

**Why this is reliable**:

1. **Browser-level API**: `chrome.downloads.onCreated` is a Chrome extension API that runs in the browser process, independent of page JS context. Regardless of how the page triggers a download (`anchor.click()`, `dispatchEvent`, `window.location`, `Navigation API`), this event always fires.

2. **Precise matching**: `item.url.startsWith('blob:')` precisely targets Gemini's blob downloads (Gemini fetches the image into memory, then creates a blob: URL to trigger download), without affecting other normal downloads.

3. **Self-protection**: The `ownDownloadIds` Set tracks download IDs initiated by our extension, ensuring we never cancel our own downloads:
   - `chrome.downloads.download()` callback immediately adds `downloadId` to `ownDownloadIds`
   - `onCreated` listener checks `ownDownloadIds` to skip our own downloads
   - After download completes/fails, the ID is removed from `ownDownloadIds`

4. **Precise timing window**: Content script sends `SUPPRESS_DOWNLOADS: true` before starting the batch download and `SUPPRESS_DOWNLOADS: false` after completion. The suppression window is only active during batch downloads, leaving normal user downloads unaffected.

**Communication path**:

```
Content Script ──chrome.runtime.sendMessage──► Background
  { type: 'SUPPRESS_DOWNLOADS', suppress: true }

Background sets suppressNativeDownloads = true

  ... during batch download ...
  Page JS triggers blob: download → chrome.downloads.onCreated → cancel + erase

Content Script ──chrome.runtime.sendMessage──► Background
  { type: 'SUPPRESS_DOWNLOADS', suppress: false }
```

### 4.4 Three-Approach Comparison

| Dimension | CustomEvent Control | postMessage Control | chrome.downloads.onCreated |
|-----------|--------------------|--------------------|---------------------------|
| Interception level | Page JS (main world) | Page JS (main world) | Browser process (background) |
| Signal delivery | CustomEvent.detail | window.postMessage | chrome.runtime.sendMessage |
| Reliability | ❌ detail lost cross-world | ❌ anchor patch unreliable | ✅ Browser-level, cannot be bypassed |
| Scope | `.click()` calls only | `.click()` calls only | Any download trigger method |
| False positive risk | Needs suppress flag | Needs suppress flag | Protected by ownDownloadIds |
| Status | Rejected | Rejected | **Current approach** |

## 5. Simulated Clicks and `isTrusted`: Deep Analysis

### 5.1 Current Mechanism

The entire download flow relies on `button.click()` — the content script locates Gemini's native "Download full size image" button and calls its `.click()` method.

```typescript
// content/index.ts
function clickAndWaitForBlob(button: HTMLButtonElement, timeoutMs = 30000): Promise<string> {
    return new Promise<string>((resolve, reject) => {
        const timer = setTimeout(() => {
            pendingBlobResolve = null;
            reject(new Error('Timeout waiting for native download response'));
        }, timeoutMs);

        pendingBlobResolve = (dataUrl: string) => {
            clearTimeout(timer);
            resolve(dataUrl);
        };

        button.click();  // Produces an isTrusted: false event
    });
}
```

The `click` event produced by `button.click()` has its `isTrusted` property set to `false`, because it was not generated by a real user input device (mouse, keyboard, or touchscreen).

### 5.2 Why `isTrusted` Cannot Be Forged

`isTrusted` is a **read-only property** on DOM event objects, set by the browser engine (Blink) when the event is created. Per the W3C UI Events spec and Mozilla Bug 637248:

- `isTrusted` is **unforgeable** — even `Object.defineProperty` cannot override it
- It is set by the C++ event constructor; no JavaScript mechanism can change it to `true`
- This is a browser security boundary: ensuring page JS can distinguish real user actions from programmatic triggers

```javascript
const event = new MouseEvent('click');
console.log(event.isTrusted); // false — always

// Even attempting to override has no effect
Object.defineProperty(event, 'isTrusted', { value: true });
console.log(event.isTrusted); // still false
```

### 5.3 Gemini's Current `isTrusted` Handling

**Verified through testing: Gemini currently does not check `isTrusted`.** `button.click()` successfully triggers the complete RPC call chain (c8o8Fe batchexecute → signed URL → redirects → original PNG), and the download flow completes normally.

This is related to Angular's event handling mechanism. Angular uses Zone.js to proxy events, and its event processing pipeline does not check `isTrusted` — Zone.js cares about event type and target element, not origin. Angular's click event bindings (e.g. `(click)="download()"`) treat trusted and untrusted events identically.

### 5.4 Industry Precedent: Simulated Clicks Are Standard Practice in Browser Extensions

`button.click()` is a **widely accepted standard practice** in the browser extension ecosystem. Notable extensions using this technique:

| Extension | Users | Simulated Click Usage |
|-----------|-------|----------------------|
| **Tampermonkey / Greasemonkey** | 10M+ | User scripts frequently use `.click()` to automate page interactions |
| **Automa** | 500K+ | Browser automation tool; simulated clicks are a core feature |
| **UI.Vision RPA** | 300K+ | Record and replay user actions; `.click()` is a fundamental API |
| **iMacros** | 100K+ | Classic browser automation plugin, 20+ year history |
| **Selenium IDE** | 100K+ | Official Selenium browser extension |
| **DownThemAll** | Legacy FF download manager | Auto-triggers clicks on download links |

**Greasemonkey Issue #2301** explicitly states: `isTrusted` is unforgeable, and extension developers can only use programmatic trigger methods like `.click()`. The vast majority of websites do not check this property. This is an established fact in the browser extension ecosystem, not a vulnerability or hack.

### 5.5 `isTrusted` Risk Assessment

**The likelihood of Google adding an `isTrusted` check to Gemini is low because:**

1. **Breaks assistive technology**: Screen readers, voice control software, and other accessibility tools also generate `isTrusted: false` events. Checking `isTrusted` would break accessibility.
2. **Angular framework convention**: Checking `isTrusted` is virtually nonexistent in the Angular ecosystem. Angular Material, CDK, and other official library tests all use `.click()` to trigger events.
3. **Testing infrastructure**: Google's own testing frameworks (Webdriver, Puppeteer) produce untrusted events when not using CDP protocol. Puppeteer's `page.click()` sends trusted input events via CDP, but `element.click()` produces untrusted events.

**However, the risk is not zero.** Google may add checks for security or anti-abuse reasons in the future. Available fallback approaches:

| Fallback | Mechanism | Cost |
|----------|-----------|------|
| `chrome.debugger` API | Inject trusted input events via CDP | Requires `debugger` permission; Chrome shows "debugging" banner |
| Hook Angular service in main world | Find the Angular download service instance and call internal methods | Heavily dependent on Angular internals; hard to locate after minification |
| Self-construct RPC | Bypass UI, send `c8o8Fe` request directly | Image token extraction is the core challenge (see below) |

## 6. Image Token Extraction: The Chicken-and-Egg Problem

### 6.1 Core Contradiction

The only way to obtain original images is to construct a `c8o8Fe` RPC request, which requires an **image token** (e.g. `$AedXnj...`). This token is stored in Angular component memory and cannot be directly retrieved from the DOM or network requests.

This creates a **chicken-and-egg problem**:
- **To download the original image**, you need the image token to construct the RPC request
- **To obtain the image token**, you need to extract it from Angular component memory
- **To access Angular component memory**, you need to get a component instance in the main world
- **Angular production mode does not expose component instances**

### 6.2 Extracting Tokens from Network Requests?

An intuitive thought: the image token must have appeared in some network response (the Gemini server must have sent it to the frontend after generating the image). Could we intercept network requests to capture these tokens?

**Theoretically possible, but extremely difficult in practice:**

1. **Token location**: Image tokens appear in Gemini's initial load or streaming batchexecute responses, nested within multiple layers of JSON and protobuf-encoded data structures. The entire response format must be reverse-engineered to extract them.

2. **Two approaches to request interception**:

   | Location | API | Capability | Limitation |
   |----------|-----|------------|------------|
   | Background (Service Worker) | `chrome.webRequest` / `chrome.declarativeNetRequest` | Can intercept all request headers and URLs | MV3 `declarativeNetRequest` is declarative — cannot read response bodies; `webRequest` is limited in MV3 |
   | Main World (page context) | Patch `window.fetch` or `XMLHttpRequest` | Full access to request and response content | Requires main world script injection; Gemini's streaming RPC response format is complex |

3. **Gemini's response format**: batchexecute responses are not standard JSON — they use a variant of Google's JSPB (JavaScript Protocol Buffers) serialization format, mixing nested arrays with string escaping. Parsing this format requires deep reverse engineering of Gemini's frontend code, and the format may change at any time.

4. **Token-to-image mapping**: Even if all tokens are successfully extracted, a mapping from token → specific image must be established. A single session may generate multiple images with different tokens that need accurate matching.

**Conclusion**: Extracting tokens from network requests is theoretically possible but the engineering complexity far exceeds the benefit, and maintenance cost is extremely high (every Gemini response format update could break the parser).

### 6.3 Why Simulated Clicks Are the Optimal Solution

The core advantage of the simulated click approach is that it **completely bypasses the token extraction problem**:

```
Simulated click flow:
button.click()
  → Angular event handler
  → Angular reads token from memory (we don't need to know the token)
  → Angular constructs c8o8Fe RPC request (we don't need to know the format)
  → Server returns signed URL (we don't need to know how it's signed)
  → fetch redirect chain (we intercept the final image blob here)
```

By letting Gemini's own JS handle everything from token reading to RPC invocation, we **treat the entire complex authentication and request chain as a black box**, intercepting only the final product (the original PNG blob). This means:

- No need to reverse-engineer Angular internal data structures
- No need to parse JSPB/protobuf response formats
- No need to manage CSRF tokens, session IDs, or other auth parameters
- When Gemini updates its RPC format, the extension doesn't need changes as long as the download button and fetch behavior remain the same

## 7. Choosing the Interception Location: Main World vs Background

### 7.1 Capability Comparison

| Dimension | Background (chrome.webRequest) | Main World (fetch/XHR patch) |
|-----------|-------------------------------|------------------------------|
| **Timing** | Before request sent / before response arrives | At call time / after response returns |
| **Read request body** | ✅ `onBeforeRequest` (MV2) / limited (MV3) | ✅ Full access |
| **Read response body** | ❌ MV3 `declarativeNetRequest` does not support | ✅ Full access (`response.clone().blob()`) |
| **Modify request headers** | ✅ `declarativeNetRequest` supports | ✅ Via patch |
| **Cross-origin requests** | ✅ With `host_permissions` | ❌ Subject to page CORS restrictions |
| **Impact on page JS** | None — fully independent | Yes — modifies page globals |
| **Detectable by page** | No | Possibly (page can check if fetch was patched) |

### 7.2 Why Image Blob Interception Is in the Main World

We need to **read the response body** (image blob data), but MV3's Background Service Worker uses `declarativeNetRequest` — a **declarative API** that can only modify headers, redirect, or block requests. It **cannot read or modify response bodies**.

`chrome.webRequest` is still available in MV3 but with limited capabilities (no longer supports blocking mode for `onBeforeRequest`) and cannot directly access response bodies.

Therefore, patching `window.fetch` in the main world is **the only way to access image response bodies without requiring additional permissions**.

### 7.3 Why CORS Rules Are in the Background

While image blob interception happens in the main world, CORS header modification is done via `declarativeNetRequest` in the background:

```json
// public/rules.json
[{
  "id": 1,
  "action": {
    "type": "modifyHeaders",
    "responseHeaders": [
      { "header": "Access-Control-Allow-Origin", "operation": "set", "value": "*" }
    ]
  },
  "condition": {
    "urlFilter": "||lh3.googleusercontent.com",
    "resourceTypes": ["xmlhttprequest"]
  }
}]
```

Page-level fetch requests are subject to CORS restrictions. Gemini's download redirect chain (`gg-dl` → `rd-gg-dl`) may cross origins; without correct CORS headers, the browser would block responses. `declarativeNetRequest` excels at this kind of header modification.

### 7.4 Responsibility Summary

| Need | Location | Reason |
|------|----------|--------|
| Intercept image blob | Main World (fetch patch) | Must read response body |
| CORS header modification | Background (declarativeNetRequest) | Declarative API excels at header operations |
| Suppress native downloads | Background (chrome.downloads.onCreated) | Browser-level API, cannot be bypassed by page |
| Watermark removal + save | Background (Service Worker) | Has full API permissions |

## 8. DOM Structure and Image Detection

### 8.1 Gemini-Generated Images vs User Reference Images

```html
<!-- Gemini-generated image (should download) -->
<single-image class="generated-image large">
  <div class="overlay-container">
    <button class="image-button">
      <img src="https://lh3...googleusercontent.com/gg/AMW1TP...=s1024-rj">
    </button>
    <div class="generated-image-controls">
      <download-generated-image-button>
        <button data-test-id="download-generated-image-button"
                aria-label="Download full size image">
        </button>
      </download-generated-image-button>
    </div>
  </div>
</single-image>

<!-- User-uploaded reference image (should exclude) -->
<user-query-file-carousel>
  <user-query-file-preview>
    <button class="preview-image-button">
      <img src="https://lh3...googleusercontent.com/gg/AMW1TP...">
    </button>
  </user-query-file-preview>
</user-query-file-carousel>
```

### 8.2 Detection Rules

1. **Exclude**: images inside `user-query-file-preview` or `user-query-file-carousel` (user-uploaded reference images)
2. **Include**: images inside `button.image-button` or `.overlay-container`
3. **Include**: URLs matching `/gg/`, `/gg-dl/`, `/rd-gg/`, `/aip-dl/` path patterns
4. **Fallback**: nearby "Download full size image" button exists and image size >= 120 px

**Note**: User-uploaded reference image URLs may also match the `/gg/` path pattern (they're also hosted on Google CDN), so **container exclusion checks must run before URL matching**.

### 8.3 Download Button Location

Locating the native download button starting from an `<img>` element:

```
<img> → closest('.overlay-container') → querySelector('button[data-test-id="download-generated-image-button"]')
```

## 9. Known Limitations and Risks

### 9.1 `button.click()` and `isTrusted`

See Section 5 for deep analysis.

**Current status**: Gemini does not check `isTrusted`; download flow triggers normally.

**Risk level**: Low. Adding an `isTrusted` check would break assistive technology and Google's own testing infrastructure.

### 9.2 Data Transfer Size

Original images are ~7 MB; as base64 dataURLs they grow to ~9.3 MB. Transferring large dataURLs via `postMessage` and `chrome.runtime.sendMessage` may cause performance issues in extreme cases.

**Mitigation**: Sequential downloads (non-concurrent); each image is fully processed before the next one begins.

### 9.3 Page Structure Dependencies

The approach depends on the following DOM structures and selectors, which may need adaptation after Gemini frontend updates:
- `.overlay-container` container
- `button[data-test-id="download-generated-image-button"]` download button
- `user-query-file-preview` / `user-query-file-carousel` user reference image containers
- `single-image.generated-image` generated image container

### 9.4 Fetch Patch Compatibility

The interceptor patches `window.fetch` and must be injected before the page's own JS loads. Currently achieved by injecting a `<script src>` tag from the content script at load time.

Potential risks:
- If the page has a Service Worker that caches fetch requests, it may bypass our patch
- The page could detect the patch by comparing `window.fetch === nativeFetch` (Gemini currently does not do this)
- If the page saves a reference to the original `fetch` before our injection, our patch won't affect those calls

### 9.5 Suppression Window Timing Risk

A time window exists between `SUPPRESS_DOWNLOADS` on/off. If a user manually triggers a blob: download within this window (very rare), that download would be incorrectly cancelled.

**Mitigation**: The suppression window is kept as short as possible (only during batch downloads) and only matches `blob:` protocol downloads.

## 10. Approach Comparison Summary

| Approach | Pros | Cons | Status |
|----------|------|------|--------|
| URL suffix rewriting (`=s0`) | Simple to implement | **Cannot get originals** (different tokens) | Rejected |
| Self-construct RPC request | No UI interaction needed | Image token inaccessible from DOM; protocol unstable; complex response format | Not adopted |
| Extract tokens from network requests | No simulated clicks needed | JSPB format hard to reverse; token-image mapping complex; extremely high maintenance cost | Analyzed and rejected |
| Intercept native download flow | Reuses page's own logic; gets real originals | Depends on DOM structure; theoretical `isTrusted` risk (practically very low) | **Current approach** |
